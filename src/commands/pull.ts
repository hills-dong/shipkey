import { Command } from "commander";
import { getBackend } from "../backends";
import { loadConfig } from "../config";
import { writeFile } from "fs/promises";
import { resolve, join, basename } from "path";

export const pullCommand = new Command("pull")
  .description("Pull keys from 1Password and generate env files")
  .option("-e, --env <env>", "environment (dev/prod)", "dev")
  .option("--vault <vault>", "1Password vault name", "shipkey")
  .option("--project <name>", "project name (defaults to directory name)")
  .option("--no-envrc", "skip .envrc generation")
  .option("--no-dev-vars", "skip .dev.vars generation")
  .argument("[dir]", "project directory", ".")
  .action(async (dir: string, opts) => {
    const projectRoot = resolve(dir);
    const project = opts.project || basename(projectRoot);
    const env = opts.env;
    const vault = opts.vault;

    let backendName = "1password";
    try {
      const config = await loadConfig(projectRoot);
      if (config.backend) backendName = config.backend;
    } catch {
      // No config file — use default backend
    }
    const backend = getBackend(backendName);

    if (!(await backend.isAvailable())) {
      console.error(
        `Error: ${backend.name} CLI not available. Run 'shipkey setup' for installation instructions.`
      );
      process.exit(1);
    }

    console.log(`Pulling keys for ${project}.${env}...\n`);

    const refs = await backend.list(project, env);

    if (refs.length === 0) {
      console.log(`No keys found for ${project}.${env} in vault ${vault}.`);
      return;
    }

    // Read all values
    const entries: { key: string; value: string; ref: typeof refs[0] }[] = [];
    for (const ref of refs) {
      try {
        const value = await backend.read(ref);
        const envKey = ref.field;
        entries.push({ key: envKey, value, ref });
        console.log(`  ✓ Restored ${envKey}`);
      } catch (err) {
        console.error(
          `  ✗ ${ref.provider}/${ref.field} — ${err instanceof Error ? err.message : err}`
        );
      }
    }

    if (entries.length === 0) return;

    // Generate .envrc
    if (opts.envrc) {
      const envrcContent = [
        `# Auto-generated by shipkey — do not edit manually`,
        `# Project: ${project}  Environment: ${env}`,
        "",
        ...entries.map((e) => {
          const inlineRef = backend.buildInlineRef?.(e.ref);
          if (inlineRef) {
            return `export ${e.key}=$(op read "${inlineRef}")`;
          }
          // Backend doesn't support inline refs — write value directly
          return `export ${e.key}="${e.value}"`;
        }),
        "",
      ].join("\n");

      await writeFile(join(projectRoot, ".envrc"), envrcContent);
      console.log(`\n  ✓ Generated .envrc`);
    }

    // Generate .dev.vars
    if (opts.devVars) {
      const devVarsContent = [
        `# Auto-generated by shipkey — do not edit manually`,
        `# Project: ${project}  Environment: ${env}`,
        "",
        ...entries.map((e) => `${e.key}=${e.value}`),
        "",
      ].join("\n");

      await writeFile(join(projectRoot, ".dev.vars"), devVarsContent);
      console.log(`  ✓ Generated .dev.vars`);
    }

    console.log(`\nRestored ${entries.length} keys for ${project}.${env}`);
  });

